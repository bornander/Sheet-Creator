package com.bornander.tools.sheetcreator;

import com.bornander.utils.ImageUtils;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.datatransfer.DataFlavor;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetDragEvent;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.dnd.DropTargetEvent;
import java.awt.dnd.DropTargetListener;
import static com.bornander.utils.Log.*;
import java.awt.Image;
import java.awt.datatransfer.Transferable;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.image.BufferedImage;
import java.awt.image.WritableRaster;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import javax.imageio.ImageIO;

public class TileGrid extends javax.swing.JPanel implements DropTargetListener {

    private class TileImage {

        public final File file;
        public final Image image;
        public int row = 0;
        public int col = 0;
        public boolean isSelected = true;

        public TileImage(File file) throws IOException {
            this.file = file;
            image = ImageIO.read(file);
        }

        public void render(Graphics2D g, int tileSize) {
            if (isSelected) {
                g.setColor(new Color(1, 0, 1, 0.5f));
                g.fillRect(col * tileSize, row * tileSize, image.getWidth(null), image.getHeight(null));

            }
            g.drawImage(image, col * tileSize, row * tileSize, null);
            if (isSelected) {

                g.setColor(Color.CYAN);
                g.drawRect(col * tileSize, row * tileSize, image.getWidth(null), image.getHeight(null));
            }
        }

        public int getExtentX(int tileSize) {
            return col * tileSize + image.getWidth(null);
        }

        public int getExtentY(int tileSize) {
            return row * tileSize + image.getHeight(null);
        }

        private boolean contains(int x, int y, int tileSize) {
            int l = col * tileSize;
            int t = row * tileSize;
            return (x >= l && x <= getExtentX(tileSize))
                    && (y >= t && y <= getExtentY(tileSize));
        }
    }

    private boolean showGrid = true;
    private int tileSize = 32;
    private int tilePadding = 1;
    private int sheetMaxSize = 1024;

    private TileImage selected = null;
    private final List<TileImage> tileImages = new ArrayList<TileImage>();

    private DropTarget dropTarget;

    private boolean dirty = false;

    public TileGrid() {
        initComponents();
        dropTarget = new DropTarget(this, DnDConstants.ACTION_COPY, this);
    }

    @Override
    public void paint(Graphics graphics) {
        Graphics2D g = (Graphics2D) graphics;

        int w = getWidth();
        int h = getHeight();

        g.setColor(Color.DARK_GRAY);
        g.fillRect(0, 0, w, h);

        int bgCellSize = tileSize / 4;
        int row = 0;

        g.setColor(Color.GRAY);
        for (int y = 0; y < h; y += bgCellSize) {
            int col = 0;
            for (int x = 0; x < w; x += bgCellSize) {
                boolean xEven = col % 2 == 0;
                boolean yEven = row % 2 == 0;
                if (!yEven && xEven) {
                    g.fillRect(x, y, bgCellSize, bgCellSize);
                }
                if (yEven && !xEven) {
                    g.fillRect(x, y, bgCellSize, bgCellSize);
                }
                ++col;
            }
            ++row;
        }

        if (selected != null) {
            selected.render(g, tileSize);
        }

        if (showGrid) {
            g.setColor(Color.WHITE);
            for (int y = 0; y < h; y += tileSize) {
                g.drawLine(0, y, w, y);
            }

            for (int x = 0; x < w; x += tileSize) {
                g.drawLine(x, 0, x, h);
            }
        }

        int maxX = 0;
        int maxY = 0;
        for (TileImage tileImage : tileImages) {
            tileImage.render(g, tileSize);
            maxX = Math.max(maxX, tileImage.getExtentX(tileSize));
            maxY = Math.max(maxY, tileImage.getExtentY(tileSize));
        }

        int maxCells = sheetMaxSize / (tileSize + tilePadding);

        g.setColor(Color.RED);
        g.drawLine(maxCells * tileSize, 0, maxCells * tileSize, h);
        g.drawLine(0, maxCells * tileSize, w, maxCells * tileSize);

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                formMouseDragged(evt);
            }
        });
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                formMousePressed(evt);
            }
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                formMouseReleased(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMousePressed
        Optional<TileImage> picked = tileImages.stream().filter(ti -> ti.contains(evt.getX(), evt.getY(), tileSize)).findFirst();
        selected = picked.orElse(null);
        if (selected != null) {
            selected.isSelected = true;
            tileImages.remove(selected);
        }
        repaint();
    }//GEN-LAST:event_formMousePressed

    private void formMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseDragged
        if (selected != null) {
            selected.row = evt.getY() / tileSize;
            selected.col = evt.getX() / tileSize;
            repaint();
        }

    }//GEN-LAST:event_formMouseDragged

    private void formMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseReleased
        if (selected != null) {
            tileImages.add(selected);
            selected = null;
        }
        tileImages.stream().forEach(ti -> ti.isSelected = false);
        repaint();
    }//GEN-LAST:event_formMouseReleased

    void setShowGrid(boolean showGrid) {
        this.showGrid = showGrid;
        repaint();
    }

    void setTileSize(int tileSize) {
        this.tileSize = tileSize;
        repaint();
    }

    void setTilePadding(int tilePadding) {
        this.tilePadding = tilePadding;
        repaint();
    }

    int getExtentX() {
        return tileImages.stream().mapToInt(ti -> ti.getExtentX(tileSize)).max().orElse(0);
    }

    int getExtentY() {
        return tileImages.stream().mapToInt(ti -> ti.getExtentY(tileSize)).max().orElse(0);
    }

    void save(File selectedFile) throws IOException {
        BufferedImage source = new BufferedImage(getExtentX(), getExtentY(), BufferedImage.TYPE_4BYTE_ABGR);
        Graphics2D sg = (Graphics2D) source.getGraphics();
        tileImages.stream().forEach(tm -> {
            tm.isSelected = false;
            tm.render(sg, tileSize);
        });

        BufferedImage target = ImageUtils.padImage(source, tileSize, tilePadding);
        ImageIO.write(target, "png", selectedFile);
        dirty = false;
    }

    @Override
    public void dragEnter(DropTargetDragEvent dtde) {
        if (dtde.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {
            Transferable transferable = dtde.getTransferable();
            try {
                List fileList = (List) transferable.getTransferData(DataFlavor.javaFileListFlavor);
                if (fileList.size() == 1) {
                    selected = new TileImage((File) fileList.get(0));
                    dtde.acceptDrag(DnDConstants.ACTION_COPY);
                }
            } catch (IOException | UnsupportedFlavorException ex) {
                e("Unable to accept drag, %s.", ex.getMessage());
            }
        } else {
            dtde.rejectDrag();
        }
    }

    @Override
    public void dragOver(DropTargetDragEvent dtde) {
        int screenX = dtde.getLocation().x;
        int screenY = dtde.getLocation().y;

        selected.row = screenY / tileSize;
        selected.col = screenX / tileSize;

        repaint();
    }

    @Override
    public void dropActionChanged(DropTargetDragEvent dtde) {
    }

    @Override
    public void dragExit(DropTargetEvent dte) {
    }

    @Override
    public void drop(DropTargetDropEvent dtde) {
        if (dtde.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {
            dtde.acceptDrop(DnDConstants.ACTION_COPY);
            tileImages.stream().forEach(tm -> tm.isSelected = false);
            tileImages.add(selected);
            selected.isSelected = false;
            selected = null;
            dirty = true;
        }
        repaint();
    }

    boolean isDirty() {
        return dirty;
    }

    void reset(int tileSize, int tilePadding) {
        tileImages.clear();
        dirty = false;
        this.tileSize = tileSize;
        this.tilePadding = tilePadding;
        repaint();
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
